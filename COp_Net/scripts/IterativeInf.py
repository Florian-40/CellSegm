import numpy as np 
import SimpleITK as sitk 
import os 
import shutil
import subprocess
import glob
import time

# COp-Net iterative inference  
def Inference(path_to_input_probamap , path_to_output_folder, cv_threshold = 0.1, max_iter = 50) : 

    """path_to_input_probamap : path to the input probamap, the file must be in .nii.gz format
    """

    # Create temporary folders to save the intermediary probability maps generated by the COp-Net
    os.makedirs('tmp', exist_ok=True)
    input_path = 'tmp/input/'
    output_path = 'tmp/output/'
    # Save the input probability map in the input temporary folder
    i = 1
    os.makedirs(os.path.join(input_path, 'CopNet_'+str(i)), exist_ok=True)
    shutil.copy2(path_to_input_probamap, os.path.join(input_path, 'CopNet_'+str(i), 'CopNet_1_0000.nii.gz'))


    
    cv_criterion = [100]
    while i <= max_iter and cv_criterion[-1] > cv_threshold : 
        print('Iteration : ', i)

        # Create the output folder and the input folder of the following iteration
        CopNet_output_folder = os.path.join(output_path, 'CopNet_'+str(i))
        CopNet_input_folder = os.path.join(input_path, 'CopNet_'+str(i))
        CopNet_nextiter_folder = os.path.join(input_path, 'CopNet_'+str(i+1))
        os.makedirs(CopNet_nextiter_folder, exist_ok=True)
        os.makedirs(CopNet_output_folder, exist_ok=True)

        # If the iteration wasn't already computed, we compute it
        if len(glob.glob(os.path.join(input_path,'CopNet_'+str(i+1),'*.nii.gz'))) == 0 or \
        len(glob.glob(os.path.join(output_path,'CopNet_'+str(i),'*.npz'))) != len(glob.glob(os.path.join(input_path,'CopNet_'+str(i),'*.nii.gz'))):
            
            start_time = time.time()
            # define environment variables for nnUNetv2
            os.environ["nnUNet_raw"] = os.path.join("COp_Net/nnUNetv2/nnUNet_raw")
            os.environ["nnUNet_preprocessed"] = os.path.join("COp_Net/nnUnetv2/nnUNet_preprocessed")
            os.environ["nnUNet_results"] = os.path.join("COp_Net/nnUNetv2/nnUNet_results")

            # run the closing network inference (through nnUNetv2 2d architecture)
            subprocess.run(["nnUNetv2_predict", "-i", CopNet_input_folder, "-o", CopNet_output_folder, "-d", "Dataset002_Real_FT_BALPubli", "-c", "2d", "-f", "0", "--save_probabilities"])
            
            # Copy the output in the input folder of the next iteration
            print('Saving the output of the iteration')  
            output = np.load(os.path.join(CopNet_output_folder, 'CopNet_'+str(i)+'.npz'))
            output = output['probabilities']
            output = output[1,:,:,:]
            sitk.WriteImage(sitk.GetImageFromArray(output), os.path.join(CopNet_nextiter_folder, 'CopNet_'+str(i+1)+'_0000.nii.gz'))
            print("--- Iteration time = %s seconds ---" % (time.time() - start_time))

        else :
            print('The iteration was already computed')
            output = sitk.ReadImage((os.path.join(CopNet_nextiter_folder, 'CopNet_'+str(i+1)+'_0000.nii.gz')))
            output = sitk.GetArrayFromImage(output)

        if i==1 : 
            previous_dilation = sitk.ReadImage(os.path.join(CopNet_input_folder, 'CopNet_1_0000.nii.gz'))
            previous_dilation = sitk.GetArrayFromImage(previous_dilation)

        # Compute the convergence criterion
        cv_criterion.append(np.sum(np.round(previous_dilation) != np.round(output))/(output.size)*100)
        print('Convergence criterion values [%]: ', cv_criterion[-1])
        previous_dilation = output
        i += 1
        
    # Save the final output in the output folder
    if cv_criterion[-1] > cv_threshold : 
        print('The maximum number of iterations has been reached')
    else :
        print(i-1, ' iterations were necessary to converge')
    os.makedirs(path_to_output_folder, exist_ok=True)
    shutil.copy2(os.path.join(CopNet_input_folder, 'CopNet_'+str(i-1)+'_0000.nii.gz'), path_to_output_folder)
    np.save(os.path.join(path_to_output_folder, 'cv_criterion.npy'), cv_criterion[1:])

    #remove the temporary folders
    shutil.rmtree('tmp')
    



